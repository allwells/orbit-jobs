# OrbitJobs Project Context

## Quick Overview

Single-user job curation platform that fetches tech jobs from JSearch API, generates viral X content using Vercel AI SDK, and posts to @TheOrbitJobs. Built with Next.js, TypeScript, Mantine, and Supabase.

## Current Implementation Status

**Active Phase**: [UPDATE THIS AS YOU PROGRESS ✅ Complete / ⏳ In Progress / ❌ Not Started]

- Phase 1: ✅ Complete
- Phase 2: ✅ Complete
- Phase 3: ✅ Complete
- Phase 4: ✅ Complete
- Phase 5: ✅ Complete
- Phase 6: ✅ Complete
- Phase 7: ✅ Complete

**Last Updated**: 2026-02-15

## Architecture Quick Reference

### Tech Stack

- **Framework**: Next.js (App Router, TypeScript, Turbopack)
- **UI**: Mantine
- **Database**: Supabase (PostgreSQL with RLS enabled)
- **Auth**: BetterAuth with Supabase adapter
- **AI**: Vercel AI SDK (OpenAI, Anthropic, Google)
- **APIs**: JSearch (RapidAPI), X API v2, Telegram Bot
- **Charts**: Chart.js
- **Package Manager**: bun

### Critical Patterns

```typescript
// Component Structure - ALWAYS follow this
/components/CNaeemmnnoopt / index.tsx; // Main component
types.ts; // Component-specific types
constants.ts; // Component-specific constants
hooks / // Component-specific hooks
  use -
  component -
  logic.ts;
utils.ts; // Component-specific utilities (if needed)

// Data Fetching - ALWAYS use custom hooks
const { data, loading, error, refetch } = useJobs(filters);

// Error Handling - ALWAYS use this pattern
try {
  setLoading(true);
  const result = await operation();
  notifications.show({ title: "Success", message: "...", color: "green" });
} catch (error) {
  console.error("Operation failed:", error);
  notifications.show({
    title: "Error",
    message: error instanceof Error ? error.message : "Failed",
    color: "red",
  });
} finally {
  setLoading(false);
}
```

### Database Schema (Key Tables)

- **users**: Admin authentication (single user: root)
- **jobs**: Job listings with status workflow (pending → approved → posted)
- **activities**: Comprehensive activity logging for all actions
- **settings**: User preferences and configuration
- **job_fetch_config**: Saved job fetch filter configurations

### File Locations

- **Services**: lib/ (supabase.ts, auth.ts, jsearch.ts, telegram.ts, ai.ts, x-api.ts)
- **Types**: types/ (database.ts, job.ts, activity.ts, api.ts, ui.ts)
- **Hooks**: hooks/ (use-auth.ts, use-jobs.ts, use-activities.ts)
- **Utils**: utils/ (formatters.ts, validators.ts, date-utils.ts)

## Design System

- **Primary Color**: Indigo #6366F1
- **Background**: #020202 (strict dark theme)
- **Text Primary**: #FFFFFF
- **Text Secondary**: #A0A0A0
- **Success**: #10B981
- **Error**: #EF4444
- **Warning**: #F59E0B

## Critical Rules (Never Violate)

1. **Zero `any` types** - Every variable, function, prop must be typed
2. **Component-based structure** - Each component in its own folder
3. **Custom hooks for data** - No direct Supabase calls in components
4. **Activity logging** - Log every significant user action
5. **Error handling** - Every async operation needs try/catch with notifications
6. **Mobile-first** - All UIs must be fully functional on mobile devices
7. **Manual triggers** - No automated job fetching, content generation, or posting

## Common Gotchas

- Modal must navigate to `/jobs` after fetch completes (not close in place)
- Dashboard shows max 10 jobs; `/jobs` page shows all with pagination
- Last run timestamp uses relative formatting (e.g., "2 hours ago", "Today at 2:42 PM")
- View preference (table/grid) persists in localStorage as `orbitjobs-view-mode`
- Job deduplication uses `job_id` from JSearch API
- Primary tweet must NOT contain link; reply tweet must contain link
- Status workflow: pending → approved → posted (no skipping states)

## Environment Variables Required

```env
# Supabase
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=
SUPABASE_SERVICE_KEY=

# BetterAuth
BETTER_AUTH_SECRET=
BETTER_AUTH_URL=

# APIs
RAPIDAPI_KEY=
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
GOOGLE_GENERATIVE_AI_API_KEY=

# X (Twitter)
X_API_KEY=
X_API_SECRET=
X_ACCESS_TOKEN=
X_ACCESS_SECRET=
X_BEARER_TOKEN=

# Telegram
TELEGRAM_BOT_TOKEN=
TELEGRAM_CHAT_ID=

# App
NEXT_PUBLIC_APP_URL=

# Admin
ADMIN_EMAIL=
ADMIN_PASSWORD=
```

## Implementation Plan Location

Full detailed implementation plan: `docs/implementation-plan.md`

## Architecture Documentation Workflow

**Critical**: After completing each phase, update `docs/architecture.md`

Each phase completion requires:

1. Review what decisions you made during implementation
2. Identify anything that wasn't explicitly in the implementation plan
3. Document those decisions in the appropriate phase section of architecture.md
4. Use the decision template format specified in agent rules
5. Only THEN mark the phase as complete

Common things to document:

- Component architecture patterns you established
- API integration quirks (e.g., "JSearch API sometimes returns null for salary_min instead of omitting the field")
- Database query optimizations (e.g., "Added compound index on (status, created_at) for jobs table to speed up filtered queries")
- Error handling patterns (e.g., "All modals use a consistent error boundary component")
- State management decisions (e.g., "Chose to lift modal state to page level instead of using URL params")
- Performance optimizations (e.g., "Implemented virtual scrolling for jobs list at 100+ items")

**Example workflow:**

1. Complete Phase 3 implementation
2. Review what you built
3. Notice you created a reusable `<JsonViewer>` component for activity metadata
4. Document this in architecture.md under Phase 3:
   - Decision: Created reusable JsonViewer component
   - Why: Activity metadata needs consistent display across modals
   - Usage: Import from components/JsonViewer, pass metadata object
5. Mark Phase 3 complete
6. Move to Phase 4

## Design System & Theme Tokens

**Critical Reference:** All color and styling decisions are defined in `docs/theme-guide.md`

### Color Token System

OrbitJobs uses a comprehensive token-based color system with perfect inverse relationships between light and dark themes. Every color in dark mode has a mathematically calculated light mode equivalent (255 - RGB value).

**Core Principle:** Dark mode `background.primary` is `#101010`, light mode is `#EFEFEF` (inverse). This applies to ALL neutral colors. Indigo brand color `#6366F1` remains constant in both themes.

**Quick Token Reference:**

**Backgrounds:**

- `background.page` - Main page background
- `background.primary` - Primary content container
- `background.secondary` - Sidebar, cards, sections
- `background.tertiary` - Nested cards, code blocks
- `background.modal` - Modal dialogs
- `background.dropdown` - Dropdown menus
- `background.input` - Form inputs
- `background.hover` - Hover state (sidebar nav = dropdown items)
- `background.active` - Active/selected state

**Borders:**

- `border.default` - Standard borders for cards, sections
- `border.subtle` - Very subtle borders
- `border.strong` - Emphasized borders
- `border.input` - Input default border
- `border.input.hover` - Input hover border
- `border.input.focus` - Input focus border (brand color)

**Text:**

- `text.primary` - Headings, body copy
- `text.secondary` - Metadata, labels
- `text.tertiary` - Captions, small text
- `text.muted` - Disabled, placeholders
- `text.inverse` - Text on colored backgrounds

**Brand (Indigo - constant):**

- `brand.primary` - Primary actions `#6366F1`
- `brand.hover` - Primary button hover
- `brand.active` - Primary button active

### Strict Design Rules (NEVER VIOLATE)

1. **No Arbitrary Colors:** Never use hex codes directly in components. Always use theme tokens.
   - ✗ Wrong: `backgroundColor: '#1A1A1A'`
   - ✓ Correct: `backgroundColor: theme.other.background.secondary`

2. **Unified Hover States:** Sidebar navigation hover and dropdown item hover MUST use the same color.
   - Both must use: `background.hover`

3. **Consistent Borders:** All components of the same type use the same border color.
   - Cards: `border.default`
   - Inputs: `border.input`
   - Subtle separations: `border.subtle`

4. **Text Hierarchy:** Follow strict text color hierarchy.
   - Headings: `text.primary`
   - Body/metadata: `text.secondary`
   - Captions: `text.tertiary`
   - Disabled: `text.muted`

5. **Focus Indicators:** All interactive elements must show `border.input.focus` on focus (brand color).

6. **Touch Targets:** Minimum 44px height for all interactive elements on mobile.

7. **Elevation System:** Use correct shadow for component elevation.
   - Cards: `shadow.sm`
   - Tooltips: `shadow.md`
   - Dropdowns: `shadow.lg`
   - Modals: `shadow.xl`

### Component Color Patterns

**Must memorize these patterns:**

**Sidebar:**

- Background: `background.secondary`
- Border: `border.sidebar`
- Nav item hover: `background.hover`
- Nav item active: `background.active` + left border `brand.primary`

**Cards/Sections:**

- Background: `background.secondary`
- Border: `border.default`
- Shadow: `shadow.sm`

**Modals:**

- Background: `background.modal`
- Border: `border.modal`
- Shadow: `shadow.xl`

**Dropdowns:**

- Background: `background.dropdown`
- Border: `border.dropdown`
- Item hover: `background.hover` (same as sidebar!)
- Item active: `background.active`
- Shadow: `shadow.lg`

**Inputs:**

- Background: `background.input`
- Border: `border.input`
- Hover border: `border.input.hover`
- Focus border: `border.input.focus` (2px, brand color)

**Buttons (Primary):**

- Background: `brand.primary`
- Text: `text.inverse`
- Hover: `brand.hover`
- Shadow: `shadow.sm`

**Tables:**

- Header background: `background.secondary`
- Header border: `border.strong` (bottom, 2px)
- Row background: `background.primary`
- Row border: `border.default`
- Row hover: `background.hover`

### Accessibility Checklist

Before marking any UI work complete, verify:

- [ ] All text/background combinations meet WCAG AA (4.5:1 for normal text)
- [ ] Focus indicators visible on all interactive elements
- [ ] Touch targets minimum 44px on mobile
- [ ] Color is not the only indicator of state/meaning
- [ ] Component works in both light and dark themes

### Mobile-First Design Principles

Every component must be built mobile-first:

1. Design for 375px width first
2. Add tablet breakpoint at 768px
3. Add desktop breakpoint at 1024px
4. Tables convert to stacked cards on mobile
5. Modals take full width on mobile with padding
6. Navigation collapses to hamburger on mobile
7. All interactive elements have 44px touch targets

### Common Design Mistakes to Catch

If you see any of these in code reviews or implementation, flag immediately:

**Color Violations:**

- Hardcoded hex colors in component styles
- Different hover colors for sidebar vs dropdown
- Arbitrary color values not in theme guide
- Missing theme token usage

**Inconsistency Violations:**

- Cards with different border colors
- Inputs with non-standard border styles
- Hover states that don't match patterns
- Missing focus indicators

**Accessibility Violations:**

- Poor color contrast (fails WCAG AA)
- Missing focus indicators
- Touch targets smaller than 44px
- Color-only state indicators

**Responsive Violations:**

- Fixed pixel widths instead of responsive units
- Missing mobile breakpoints
- Non-functional touch interactions
- Tables that don't adapt to mobile

### How to Use Theme in Components

**Always use Mantine's theme system:**

```typescript
import { useMantineTheme } from '@mantine/core';

function MyComponent() {
  const theme = useMantineTheme();

  return (
    <Box
      sx={{
        backgroundColor: theme.other.background.secondary,
        border: '1px solid',
        borderColor: theme.other.border.default,
        color: theme.other.text.primary,
        '&:hover': {
          backgroundColor: theme.other.background.hover,
        },
      }}
    >
      Content
    </Box>
  );
}
```

**For Mantine components:**

```typescript
<Button
  sx={(theme) => ({
    backgroundColor: theme.other.brand.primary,
    color: theme.other.text.inverse,
    '&:hover': {
      backgroundColor: theme.other.brand.hover,
    },
  })}
>
  Click me
</Button>
```

### Design System Reference Files

**Must review before any UI work:**

1. `docs/theme-guide.md` - Complete color palette and component specs
2. `.agent/rules` - Design enforcement rules
3. This section - Quick reference and common patterns

**If you're unsure about any styling decision:**

1. Check theme-guide.md for the component type
2. Use the exact tokens specified
3. Test in both light and dark themes
4. Verify accessibility requirements
5. Get confirmation before implementing custom patterns

### Design System Updates

**When to update design system:**

- Adding new component types not in theme guide
- Discovering new color tokens needed
- Establishing new interaction patterns
- Finding accessibility improvements

**How to update:**

1. Document the need in architecture.md
2. Get approval for the addition
3. Update theme-guide.md with new tokens/patterns
4. Update .context.md with new quick reference
5. Update .agent/rules if new enforcement needed
6. Ensure consistency with existing patterns

### Design Quality Gates

Before marking any phase complete that includes UI work:

1. All components use theme tokens (no hardcoded colors)
2. Component works correctly in light and dark themes
3. Accessibility checklist is complete
4. Mobile responsiveness verified at all breakpoints
5. Hover states match established patterns
6. Focus indicators are visible
7. Touch targets meet minimum size
8. No console warnings about theme usage

**Quality assurance questions:**

- Can you switch themes without any visual bugs?
- Are hover states consistent across similar components?
- Do all interactive elements have visible focus indicators?
- Does it work well on a 375px mobile screen?
- Would a colorblind user understand the UI states?

## Questions to Ask Before Implementing

1. Does this follow the component-based structure?
2. Are all types strictly defined (no `any`)?
3. Does this include proper error handling?
4. Is activity logging included for user actions?
5. Is this mobile-responsive?
6. Are environment variables used for sensitive data?

## Admin Credentials

**Username**: [See .env file]
**Password**: [See .env file]
(Stored hashed in database, never in code)
